using System;
using System.Collections.Generic;
using System.Linq;
using Foillan.Models.Biodiversity;
using Foillan.Models.DataAccess.Abstract;

namespace Foillan.Models.DataAccess.Concrete
{
    public class TaxonService : ITaxonService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IRepository<Taxon> _taxonRepository;

        public TaxonService(IUnitOfWork unitOfWork, IRepository<Taxon> taxonRepository)
        {
            _unitOfWork = unitOfWork;
            _taxonRepository = taxonRepository;
        }

        public virtual Taxon AddTaxon(Taxon newTaxon, Taxonomy taxonomy)
        {
            if (newTaxon == null || newTaxon.Rank == TaxonRank.Null)
            {
                throw new ArgumentException("Rank invalid");
            }

            var taxonomyDictionary = new Dictionary<TaxonRank, String>
            {
                {TaxonRank.Kingdom, taxonomy.Kingdom},
                {TaxonRank.Phylum, taxonomy.Phylum},
                {TaxonRank.Class, taxonomy.Class},
                {TaxonRank.Order, taxonomy.Order},
                {TaxonRank.Family, taxonomy.Family},
                {TaxonRank.Genus, taxonomy.Genus},
                {TaxonRank.Species, taxonomy.Species},
                {TaxonRank.Subspecies, taxonomy.SubSpecies}
            };

            if (!TaxonomyContainsAncestors(newTaxon.Rank, taxonomyDictionary))
            {
                throw new ArgumentException("Taxonony invalid");
            }

            var life = _taxonRepository.GetById(1);
            return CreateRanks(life, newTaxon, taxonomyDictionary);
        }

        private Taxon CreateRanks(Taxon rootTaxon, Taxon newTaxon, IReadOnlyDictionary<TaxonRank, string> taxonomy)
        {
            var currentRank = TaxonRank.Kingdom;
            var parent = rootTaxon;
            while (true)
            {
                if (newTaxon.Rank == currentRank)
                {
                    newTaxon.ParentTaxon = parent;
                    return AddNewOrReturnExistingTaxon(newTaxon);
                }
                var taxonForCurrentRank = GenerateStubTaxon(taxonomy[currentRank], currentRank);
                taxonForCurrentRank.ParentTaxon = parent;
                taxonForCurrentRank = AddNewOrReturnExistingTaxon(taxonForCurrentRank);
                currentRank++;
                parent = taxonForCurrentRank;
            }
        }

        public virtual IEnumerable<Taxon> GetTaxaByRank(TaxonRank rank)
        {
            var taxaOfRank = _taxonRepository.GetAll().Where(t => t.Rank.Equals(rank));
            return taxaOfRank;
        }

        public virtual Taxon GetTaxonById(int id)
        {
            return _taxonRepository.GetById(id);
        }

        public Taxon GetTaxonByNameAndRank(string taxonLatinName, TaxonRank rank)
        {
            if (rank == 0 || rank > TaxonRank.Subspecies)
            {
                throw new ArgumentException("Taxon Rank is invalid");
            }

            if (String.IsNullOrEmpty(taxonLatinName))
            {
                throw new ArgumentException("Taxon Latin Name is invalid");
            }

            var taxon = _taxonRepository.GetAll().Where(t => t.LatinName == taxonLatinName && t.Rank.Equals(rank)).ToList();
            if (!taxon.Any())
            {
                return null;
            }

            if (taxon.Count() > 1)
            {
                throw new NotImplementedException("Multiple matches not handled yet");
            }

            return taxon.FirstOrDefault();
        }

        public virtual void SaveChanges()
        {
            _unitOfWork.Save();
        }

        private Taxon AddNewOrReturnExistingTaxon(Taxon taxon)
        {
            var existingTaxon = _taxonRepository.GetAll().FirstOrDefault(
                t => t.LatinName == taxon.LatinName
                && t.Rank == taxon.Rank
                && t.ParentTaxon == taxon.ParentTaxon);

            if (existingTaxon != null) return existingTaxon;
            var result = _taxonRepository.Add(taxon);
            if (result == null) throw new Exception("Repository returned a null taxon");
            return result;
        }

        private static Taxon GenerateStubTaxon(string latinName, TaxonRank rank)
        {
            return new Taxon
            {
                LatinName = latinName,
                Rank = rank,
                Description = "Autogenerated taxon stub."
            };
        }

        private static bool TaxonomyContainsAncestors(TaxonRank rank, Dictionary<TaxonRank, String> heirarchy)
        {
            var level = TaxonRank.Kingdom;
            while (level < rank)
            {
                if (String.IsNullOrEmpty(heirarchy[level]))
                {
                    return false;
                }
                level++;
            }
            return true;
        }
    }
}